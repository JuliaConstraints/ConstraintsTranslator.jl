"""
    extract_structure(model <: AbstractLLM, description <: AbstractString)
Extracts the parameters, decision variables and constraints of an optimization problem 
given a natural-language `description`.
Returns a Markdown-formatted text containing the above information.
"""
function extract_structure(
        model::AbstractLLM,
        description::AbstractString,
        constraints::AbstractString,
)
    package_path::String = pkgdir(@__MODULE__)
    template_path = joinpath(package_path, "templates", "ExtractStructure.json")
    template = read_template(template_path)
    prompt = format_template(template; description, constraints)
    response = stream_completion(model, prompt)

    options = [
        "Accept the response",
        "Edit the response",
        "Try again with a different prompt",
        "Try again with the same prompt",
    ]
    menu = RadioMenu(options; pagesize = 4)

    while true
        choice = request("What do you want to do?", menu)
        if choice == 1
            break
        elseif choice == 2
            response = edit_in_editor(response)
            println(response)
        elseif choice == 3
            description = edit_in_editor(description)
            prompt = format_template(template; description, constraints)
            response = stream_completion(model, prompt)
        elseif choice == 4
            response = stream_completion(model, prompt)
        elseif choice == -1
            InterruptException()
        end
    end
    return response
end

"""
    jumpify_model(model::AbstractLLM, description::AbstractString, examples::AbstractString)
Translates the natural language `description` of an optimization problem into a JuMP constraints
programming model to be solved with CBL by querying the Large Language Model `model`. 
The `examples` are snippets from `ConstraintModels.jl` used as in-context examples to the LLM.
To work optimally, the model expects the `description` to be a structured Markdown-formatted
description as the ones generated by `extract_structure`.
Returns a Markdown-formatted text containing Julia code in a code block.
"""
function jumpify_model(
        model::AbstractLLM,
        description::AbstractString,
        examples::AbstractString,
)
    package_path::String = pkgdir(@__MODULE__)
    template_path = joinpath(package_path, "templates", "JumpifyModel.json")
    template = read_template(template_path)
    prompt = format_template(template; description, examples)
    response = stream_completion(model, prompt)

    while true
        code = parse_code(response)["julia"]
        parsed_expr = Meta.parse(code, raise = false)
        error_message = ""
        if parsed_expr.head == :incomplete || parsed_expr.head == :error
            parse_error = parsed_expr.args[1]
            error_message = string(parse_error)
        end
        options = [
            "Accept the response",
            "Edit the response",
            "Try again with a different prompt",
            "Try again with the same prompt",
        ]
        if !isempty(error_message)
            @warn "The generated Julia code has one or more syntax errors!"
            push!(options, "Fix syntax errors")
        end
        menu = RadioMenu(options; pagesize = 5)
        choice = request("What do you want to do?", menu)
        if choice == 1
            break
        elseif choice == 2
            response = edit_in_editor(response)
            println(response)
        elseif choice == 3
            description = edit_in_editor(description)
            prompt = format_template(template; description, examples)
            response = stream_completion(model, prompt)
        elseif choice == 4
            response = stream_completion(model, prompt)
        elseif choice == 5
            response = fix_syntax_errors(model, code, error_message)
        elseif choice == -1
            InterruptException()
        end
    end
    return response
end

"""
    fix_syntax_errors(model::AbstractLLM, code::AbstractString, error::AbstractString)
Fixes syntax errors in the `code` by querying the Large Language Model `model`, based on
an `error` produced by the Julia parser.
Returns Markdown-formatted text containing the corrected code in a Julia code block.
"""
function fix_syntax_errors(model::AbstractLLM, code::AbstractString, error::AbstractString)
    package_path::String = pkgdir(@__MODULE__)
    template_path = joinpath(package_path, "templates", "FixJuliaSyntax.json")
    template = read_template(template_path)
    prompt = format_template(template; code, error)
    response = stream_completion(model, prompt)
    return response
end

"""
    translate(model::AbstractLLM, description::AbstractString)
Translate the natural-language `description` of an optimization problem into 
a Constraint Programming model by querying the Large Language Model `model`.
"""
function translate(model::AbstractLLM, description::AbstractString)
    constraints = String[]
    for (name, cons) in USUAL_CONSTRAINTS
        push!(constraints, "$(name): $(lstrip(cons.description))")
    end
    constraints = join(constraints, "\n")

    structure = extract_structure(model, description, constraints)

    package_path::String = pkgdir(@__MODULE__)
    examples_path = joinpath(package_path, "examples")
    examples_files = filter(x -> endswith(x, ".md"), readdir(examples_path))
    examples = []
    for file in examples_files
        example = read(joinpath(examples_path, file), String)
        push!(examples, example)
    end
    examples = join(examples, "\n")

    response = jumpify_model(model, structure, examples)

    return parse_code(response)["julia"]
end
