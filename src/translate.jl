const MAX_RETRIES::Int = 3

"""
    extract_structure(model <: AbstractLLM, description <: AbstractString)
Extracts the parameters, decision variables and constraints of an optimization problem 
given a natural-language `description`.
Returns a Markdown-formatted text containing the above information.
"""
function extract_structure(
        model::AbstractLLM,
        description::AbstractString,
        constraints::AbstractString,
        interactive::Bool,
)
    package_path = get_package_path()
    prompt_template_path = joinpath(package_path, "templates", "ExtractStructure.json")
    prompt_template = read_template(prompt_template_path)

    prompt = format_template(prompt_template; description, constraints)
    response = stream_completion(model, prompt)

    if interactive
        options = [
            "Accept the response",
            "Edit the response",
            "Try again with a different prompt",
            "Try again with the same prompt",
        ]
        menu = RadioMenu(options; pagesize = 5)

        while true
            choice = request("What do you want to do?", menu)
            if choice == 1
                break
            elseif choice == 2
                response = edit_in_editor(response)
                println(response)
            elseif choice == 3
                description = edit_in_editor(description)
                prompt = format_template(prompt_template; description, constraints)
                response = stream_completion(model, prompt)
            elseif choice == 4
                response = stream_completion(model, prompt)
            elseif choice == -1
                InterruptException()
            end
        end
    end
    return response
end

"""
    jumpify_model(model::AbstractLLM, description::AbstractString, examples::AbstractString)
Translates the natural language `description` of an optimization problem into a JuMP constraints
programming model to be solved with CBL by querying the Large Language Model `model`. 
The `examples` are snippets from `ConstraintModels.jl` used as in-context examples to the LLM.
To work optimally, the model expects the `description` to be a structured Markdown-formatted
description as the ones generated by `extract_structure`.
Returns a Markdown-formatted text containing Julia code in a code block.
"""
function jumpify_model(
        model::AbstractLLM,
        description::AbstractString,
        examples::AbstractString,
        interactive::Bool,
)
    package_path = get_package_path()
    template_path = joinpath(package_path, "templates", "JumpifyModel.json")
    template = read_template(template_path)
    prompt = format_template(template; description, examples)
    response = stream_completion(model, prompt)

    if interactive
        while true
            code = parse_code(response)["julia"]
            error_message = check_syntax_errors(code)

            options = [
                "Accept the response",
                "Edit the response",
                "Try again with a different prompt",
                "Try again with the same prompt",
            ]
            if !isempty(error_message)
                @warn "The generated Julia code has one or more syntax errors!"
                push!(options, "Fix syntax errors")
            end
            menu = RadioMenu(options; pagesize = 5)

            choice = request("What do you want to do?", menu)
            if choice == 1
                break
            elseif choice == 2
                response = edit_in_editor(response)
                println(response)
            elseif choice == 3
                description = edit_in_editor(description)
                prompt = format_template(template; description, examples)
                response = stream_completion(model, prompt)
            elseif choice == 4
                response = stream_completion(model, prompt)
            elseif choice == 5
                response = fix_syntax_errors(model, code, error_message)
            elseif choice == -1
                InterruptException()
            end
        end
    else
        code = parse_code(response)["julia"]
        error_message = check_syntax_errors(code)
        if !isempty(error_message)
            @warn "The generated Julia code has one or more syntax errors!"
            for _ in 1:MAX_RETRIES
                response = fix_syntax_errors(model, code, error_message)
                code = parse_code(response)["julia"]
                error_message = check_syntax_errors(code)
                if isempty(error_message)
                    break
                end
                @warn "The generated Julia code has one or more syntax errors!"
            end
        end
    end
    return response
end

"""
    fix_syntax_errors(model::AbstractLLM, code::AbstractString, error::AbstractString)
Fixes syntax errors in the `code` by querying the Large Language Model `model`, based on
an `error` produced by the Julia parser.
Returns Markdown-formatted text containing the corrected code in a Julia code block.
"""
function fix_syntax_errors(model::AbstractLLM, code::AbstractString, error::AbstractString)
    package_path = get_package_path()
    template_path = joinpath(package_path, "templates", "FixJuliaSyntax.json")
    template = read_template(template_path)
    prompt = format_template(template; code, error)
    response = stream_completion(model, prompt)
    return response
end

"""
    translate(model::AbstractLLM, description::AbstractString; interactive::Bool = false)
Translate the natural-language `description` of an optimization problem into 
a Constraint Programming model by querying the Large Language Model `model`.
If `interactive`, the user will be prompted via the command line to inspect the 
intermediate outputs of the LLM, and possibly modify them.
"""
function translate(
        model::AbstractLLM,
        description::AbstractString;
        interactive::Bool = false,
)
    constraints = String[]
    for (name, cons) in USUAL_CONSTRAINTS
        push!(constraints, "$(name): $(lstrip(cons.description))")
    end
    constraints = join(constraints, "\n")

    structure = extract_structure(model, description, constraints, interactive)

    package_path = get_package_path()
    examples_path = joinpath(package_path, "examples")
    examples_files = filter(x -> endswith(x, ".md"), readdir(examples_path))
    examples = []
    for file in examples_files
        example = read(joinpath(examples_path, file), String)
        push!(examples, example)
    end
    examples = join(examples, "\n")

    response = jumpify_model(model, structure, examples, interactive)

    return parse_code(response)["julia"]
end
